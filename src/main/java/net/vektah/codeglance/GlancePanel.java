/*
 * Copyright Â© 2013, Adam Scarr
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice, this
 *    list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 *    this list of conditions and the following disclaimer in the documentation
 *    and/or other materials provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND
 * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
 * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE
 * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR
 * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

package net.vektah.codeglance;

import com.intellij.openapi.components.ServiceManager;
import com.intellij.openapi.diagnostic.Logger;
import com.intellij.openapi.editor.Editor;
import com.intellij.openapi.editor.ScrollType;
import com.intellij.openapi.editor.event.DocumentAdapter;
import com.intellij.openapi.editor.event.DocumentEvent;
import com.intellij.openapi.editor.event.VisibleAreaEvent;
import com.intellij.openapi.editor.event.VisibleAreaListener;
import com.intellij.openapi.fileEditor.FileEditor;
import com.intellij.openapi.fileEditor.TextEditor;
import com.intellij.openapi.fileTypes.SyntaxHighlighter;
import com.intellij.openapi.fileTypes.SyntaxHighlighterFactory;
import com.intellij.openapi.project.Project;
import com.intellij.psi.PsiDocumentManager;
import com.intellij.psi.PsiFile;
import net.vektah.codeglance.config.ConfigChangeListener;
import net.vektah.codeglance.config.ConfigService;
import net.vektah.codeglance.render.CoordinateHelper;
import net.vektah.codeglance.render.Minimap;
import net.vektah.codeglance.render.RenderTask;
import net.vektah.codeglance.render.TaskRunner;

import javax.swing.*;
import java.awt.*;
import java.awt.event.ComponentAdapter;
import java.awt.event.ComponentEvent;
import java.awt.event.MouseAdapter;
import java.awt.event.MouseEvent;
import java.lang.reflect.Array;

/**
 * This JPanel gets injected into editor windows and renders a image generated by GlanceFileRenderer
 */
public class GlancePanel extends JPanel implements VisibleAreaListener {
	public static final int MAX_WIDTH = 110;        // TODO: This should probably be a config option.
	private final TaskRunner runner;
	private Editor editor;
	private Minimap[] minimaps = new Minimap[2];
	private Integer activeBuffer = -1;
	private Integer nextBuffer = 0;
	private JPanel container;
	private Logger logger = Logger.getInstance(getClass().getName());
	private Project project;
	private Boolean updatePending = false;
	private boolean dirty = false;
	private CoordinateHelper coords = new CoordinateHelper();
	private ConfigService configService = ServiceManager.getService(ConfigService.class);

	public GlancePanel(Project project, FileEditor fileEditor, JPanel container, TaskRunner runner) {
		this.runner = runner;
		this.editor = ((TextEditor) fileEditor).getEditor();
		this.container = container;
		this.project = project;
		coords.setPixelsPerLine(configService.getState().pixelsPerLine);

		container.addComponentListener(new ComponentAdapter() {
			@Override public void componentResized(ComponentEvent componentEvent) {
				updateSize();
				GlancePanel.this.revalidate();
				GlancePanel.this.repaint();
			}
		});

		editor.getDocument().addDocumentListener(new DocumentAdapter() {
			@Override public void documentChanged(DocumentEvent documentEvent) {
				updateImage();
			}
		});

		configService.add(new ConfigChangeListener() {
			@Override public void configChanged() {
				coords.setPixelsPerLine(configService.getState().pixelsPerLine);
				updateImage();
			}
		});

		editor.getScrollingModel().addVisibleAreaListener(this);
		MouseListener listener = new MouseListener();
		addMouseListener(listener);
		addMouseMotionListener(listener);

		updateSize();
		for(int i = 0; i < Array.getLength(minimaps); i++) {
			minimaps[i] = new Minimap(configService.getState());
		}
		updateImage();
	}

	/**
	 * Adjusts the panels size to be a percentage of the total window
	 */
	private void updateSize() {
		// Window should not take up more then 10%
		int percentageWidth = container.getWidth() / 10;
		// but shouldn't be too wide either. 100 chars wide should be enough to visualize a code outline.
		int totalWidth = Math.min(percentageWidth, MAX_WIDTH);

		Dimension size = new Dimension(totalWidth, 0);
		setPreferredSize(size);
	}

	/**
	 * Fires off a new task to the worker thread. This should only be called from the ui thread.
	 */
	private void updateImage() {
		PsiFile file = PsiDocumentManager.getInstance(project).getPsiFile(editor.getDocument());
		if (file == null) {
			return;
		}

		synchronized (this) {
			// If we have already sent a rendering job off to get processed then first we need to wait for it to finish.
			// see updateComplete for dirty handling. The is that there will be fast updates plus one final update to
			// ensure accuracy, dropping any requests in the middle.
			if(updatePending) {
				dirty = true;
				return;
			}
			updatePending = true;
		}

		if(project.isDisposed()) return;

		SyntaxHighlighter hl = SyntaxHighlighterFactory.getSyntaxHighlighter(file.getLanguage(), project, file.getVirtualFile());

		nextBuffer = activeBuffer == 0 ? 1 : 0;

		runner.add(new RenderTask(minimaps[nextBuffer], editor.getDocument().getText(), editor.getColorsScheme(), hl, new Runnable() {
			@Override public void run() {
				updateComplete();
			}
		}));
	}

	private void updateComplete() {
		synchronized (this) {
			updatePending = false;
		}

		if(dirty) {
			SwingUtilities.invokeLater(new Runnable() {
				@Override public void run() {
					updateImage();
					dirty = false;
				}
			});
		}

		activeBuffer = nextBuffer;

		repaint();
	}

	private float getHidpiScale() {
		// Work around for apple going full retard with half pixel pixels.
		Float scale = (Float)Toolkit.getDefaultToolkit().getDesktopProperty("apple.awt.contentScaleFactor");
		if(scale == null) {
			scale = 1.0f;
		}

		return scale;
	}

	@Override
	public void paint(Graphics g) {
		g.setColor(editor.getColorsScheme().getDefaultBackground());
		g.fillRect(0, 0, getWidth(), getHeight());

		logger.debug(String.format("Rendering to buffer: %d", activeBuffer));
		if(activeBuffer >= 0) {
			Minimap minimap = minimaps[activeBuffer];

			coords.setImageHeight(minimap.height)
				.setPanelHeight(getHeight())
				.setPanelWidth(getWidth())
				.setFirstVisibleLine(editor.xyToLogicalPosition(new Point(0, (int) editor.getScrollingModel().getVisibleArea().getY())).line)
				.setLastVisibleLine(editor.xyToLogicalPosition(new Point(0, (int) editor.getScrollingModel().getVisibleArea().getMaxY())).line)
				.setHidpiScale(getHidpiScale());

			Rectangle src = coords.getImageSource();
			Rectangle dest = coords.getImageDestination();

			// Draw the image and scale it to stretch vertically.
			g.drawImage(minimap.img,                                                    // source image
					dest.x, dest.y, dest.width, dest.height,
					src.x, src.y, src.width, src.height,
					null);

			Rectangle viewport = coords.getViewport();
			g.setColor(Color.GRAY);
			Graphics2D g2d = (Graphics2D) g;
			g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.40f));
			g2d.drawRect(viewport.x, viewport.y, viewport.width, viewport.height);
			g2d.setComposite(AlphaComposite.getInstance(AlphaComposite.SRC_OVER, 0.15f));
			g2d.fillRect(viewport.x, viewport.y, viewport.width, viewport.height);
		}
	}

	@Override public void visibleAreaChanged(VisibleAreaEvent visibleAreaEvent) {
		updateSize();
		repaint();
	}

	private class MouseListener extends MouseAdapter {
		@Override public void mouseDragged(MouseEvent e) {
			// Disable animation when dragging for better experience.
			editor.getScrollingModel().disableAnimation();
			editor.getScrollingModel().scrollTo(coords.getPositionFor(e.getX(), e.getY(), true), ScrollType.CENTER);
			editor.getScrollingModel().enableAnimation();
		}

		@Override public void mouseClicked(MouseEvent e) {
			editor.getScrollingModel().scrollTo(coords.getPositionFor(e.getX(), e.getY(), false), ScrollType.CENTER);
		}
	}
}
